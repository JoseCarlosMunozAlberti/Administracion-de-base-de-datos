
USE gestion_cursos;

-- =========================
-- TABLAS BASE
-- =========================

CREATE TABLE roles (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nombre VARCHAR(50) NOT NULL UNIQUE
);

CREATE TABLE permisos (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL UNIQUE
);

CREATE TABLE rol_permiso (
    id INT AUTO_INCREMENT PRIMARY KEY,
    rol_id INT NOT NULL,
    permiso_id INT NOT NULL,
    FOREIGN KEY (rol_id) REFERENCES roles(id),
    FOREIGN KEY (permiso_id) REFERENCES permisos(id)
);

CREATE TABLE usuarios (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    email VARCHAR(100) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    rol_id INT NOT NULL,
    fecha_registro TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    activo BOOLEAN DEFAULT TRUE,
    FOREIGN KEY (rol_id) REFERENCES roles(id)
);

CREATE TABLE tokens (
    id INT AUTO_INCREMENT PRIMARY KEY,
    usuario_id INT NOT NULL,
    token VARCHAR(255) NOT NULL,
    tipo ENUM('verificacion','recuperacion') NOT NULL,
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    fecha_expiracion TIMESTAMP NULL,  
    usado BOOLEAN DEFAULT FALSE,
    FOREIGN KEY (usuario_id) REFERENCES usuarios(id)
);


CREATE TABLE cursos (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    descripcion TEXT,
    profesor_id INT NOT NULL,
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (profesor_id) REFERENCES usuarios(id)
);

CREATE TABLE inscripciones (
    id INT AUTO_INCREMENT PRIMARY KEY,
    usuario_id INT NOT NULL,
    curso_id INT NOT NULL,
    fecha_inscripcion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (usuario_id) REFERENCES usuarios(id),
    FOREIGN KEY (curso_id) REFERENCES cursos(id),
    UNIQUE (usuario_id, curso_id)
);

CREATE TABLE logs_acceso (
    id INT AUTO_INCREMENT PRIMARY KEY,
    usuario_id INT NOT NULL,
    accion VARCHAR(100) NOT NULL,
    fecha TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (usuario_id) REFERENCES usuarios(id)
);

-- =========================
-- DATOS INICIALES
-- =========================

INSERT INTO roles (nombre) VALUES ('Administrador'), ('Profesor'), ('Estudiante');

-- =========================
-- PROCEDIMIENTOS ALMACENADOS
-- =========================

DELIMITER //

-- Insertar un nuevo usuario
CREATE PROCEDURE sp_insertar_usuario(
    IN p_nombre VARCHAR(100),
    IN p_email VARCHAR(100),
    IN p_password VARCHAR(255),
    IN p_rol_id INT
)
BEGIN
    INSERT INTO usuarios (nombre, email, password, rol_id)
    VALUES (p_nombre, p_email, p_password, p_rol_id);
END //

-- Insertar un curso (solo si el usuario es profesor)
CREATE PROCEDURE sp_insertar_curso(
    IN p_nombre VARCHAR(100),
    IN p_descripcion TEXT,
    IN p_profesor_id INT
)
BEGIN
    IF (SELECT rol_id FROM usuarios WHERE id = p_profesor_id) = 2 THEN
        INSERT INTO cursos (nombre, descripcion, profesor_id)
        VALUES (p_nombre, p_descripcion, p_profesor_id);
    ELSE
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'El usuario no tiene rol de Profesor';
    END IF;
END //

-- Login (retorna datos del usuario, la validación del hash se hace en PHP)
CREATE PROCEDURE sp_login_usuario(
    IN p_email VARCHAR(100)
)
BEGIN
    SELECT id, nombre, email, password, rol_id
    FROM usuarios
    WHERE email = p_email AND activo = TRUE;
END //

-- Inscribir estudiante en un curso
CREATE PROCEDURE sp_inscribir_estudiante(
    IN p_usuario_id INT,
    IN p_curso_id INT
)
BEGIN
    IF (SELECT rol_id FROM usuarios WHERE id = p_usuario_id) = 3 THEN
        INSERT INTO inscripciones (usuario_id, curso_id)
        VALUES (p_usuario_id, p_curso_id);
    ELSE
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'El usuario no tiene rol de Estudiante';
    END IF;
END //

CREATE PROCEDURE sp_eliminar_usuario(
    IN p_usuario_id INT
)
BEGIN
    DECLARE v_rol INT;
    SELECT rol_id INTO v_rol FROM usuarios WHERE id = p_usuario_id;
    IF v_rol = 1 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'No se puede eliminar administradores';
    END IF;

    -- Eliminar dependencias
    DELETE FROM inscripciones WHERE usuario_id = p_usuario_id;
    DELETE FROM tokens WHERE usuario_id = p_usuario_id;
    DELETE FROM logs_acceso WHERE usuario_id = p_usuario_id;

    -- Si fuera profesor, reasignar o eliminar sus cursos (aquí, ejemplo: eliminar cursos y sus inscripciones)
    DELETE i FROM inscripciones i
      JOIN cursos c ON c.id = i.curso_id
      WHERE c.profesor_id = p_usuario_id;
    DELETE FROM cursos WHERE profesor_id = p_usuario_id;

    -- Finalmente, eliminar el usuario
    DELETE FROM usuarios WHERE id = p_usuario_id AND rol_id <> 1;
END //
DELIMITER ;

-- =========================
-- TRIGGERS
-- =========================

DELIMITER //
CREATE TRIGGER trg_log_cambio_password
AFTER UPDATE ON usuarios
FOR EACH ROW
BEGIN
    IF OLD.password <> NEW.password THEN
        INSERT INTO logs_acceso (usuario_id, accion)
        VALUES (NEW.id, 'Cambio de contraseña');
    END IF;
END //
DELIMITER ;


USE gestion_cursos;

-- =========================
-- USUARIOS DE PRUEBA
-- =========================
CALL sp_insertar_usuario('joseadmin', 'josecarlosmunozalberti@gmail.com', 'admin123', 1);
CALL sp_insertar_usuario('Pedro Profesor', 'profesor@example.com', 'profesor123', 2);
CALL sp_insertar_usuario('Ana Estudiante', 'ana@example.com', 'estudiante123', 3);
CALL sp_insertar_usuario('Luis Estudiante', 'luis@example.com', 'estudiante123', 3);

-- =========================
-- CURSOS DE PRUEBA
-- =========================
-- Solo el Profesor puede crear cursos
CALL sp_insertar_curso('Matemáticas Básicas', 'Curso introductorio de matemáticas', 2);
CALL sp_insertar_curso('Programación en PHP', 'Aprende fundamentos de PHP y MVC', 2);

-- =========================
-- INSCRIPCIONES
-- =========================
-- Solo los estudiantes se pueden inscribir
CALL sp_inscribir_estudiante(3, 1); -- Ana se inscribe a Matemáticas Básicas
CALL sp_inscribir_estudiante(4, 2); -- Luis se inscribe a Programación en PHP
CALL sp_inscribir_estudiante(3, 2); -- Ana también se inscribe a Programación en PHP

-- =========================
-- LOGS DE PRUEBA
-- =========================
INSERT INTO logs_acceso (usuario_id, accion) VALUES
(1, 'Login exitoso'),
(2, 'Creó un curso'),
(3, 'Se inscribió a un curso');

-- Actualizar contraseñas de usuarios de prueba con hashes seguros
USE gestion_cursos;


USE gestion_cursos;
UPDATE usuarios SET password = '$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi' 
WHERE email IN ('admin@example.com', 'profesor@example.com', 'ana@example.com', 'luis@example.com');


-- Verificar que se actualizaron`
SELECT id, nombre, email, LEFT(password, 10) as password_preview FROM usuarios;

CREATE TABLE IF NOT EXISTS password_resets (
  email VARCHAR(100) NOT NULL PRIMARY KEY,
  token VARCHAR(128) NOT NULL,
  expira DATETIME NOT NULL,
  INDEX (token)
);

-- 1) Ampliar tipos de token para incluir OTP de login
ALTER TABLE tokens 
MODIFY COLUMN tipo ENUM('verificacion','recuperacion','login_otp') NOT NULL;

-- Índice útil para validación de OTP
CREATE INDEX idx_tokens_login_otp ON tokens (usuario_id, tipo, token, usado, fecha_expiracion);

-- 2) Crear tabla de historial de contraseñas
CREATE TABLE IF NOT EXISTS password_historial (
  id INT AUTO_INCREMENT PRIMARY KEY,
  usuario_id INT NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  creado_en TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (usuario_id) REFERENCES usuarios(id),
  INDEX idx_ph_usuario_fecha (usuario_id, creado_en)
);

-- 3) Backfill: insertar las contraseñas actuales al historial (una sola vez)
INSERT INTO password_historial (usuario_id, password_hash, creado_en)
SELECT u.id, u.password, NOW()
FROM usuarios u
LEFT JOIN (
  SELECT usuario_id FROM password_historial GROUP BY usuario_id
) ph ON ph.usuario_id = u.id
WHERE ph.usuario_id IS NULL;

-- 4) (Opcional) Limpiar tokens OTP expirados periódicamente (si tienes eventos)
-- CREATE EVENT IF NOT EXISTS ev_cleanup_tokens
-- ON SCHEDULE EVERY 1 HOUR
-- DO
--   DELETE FROM tokens WHERE tipo='login_otp' AND (fecha_expiracion IS NOT NULL AND fecha_expiracion < NOW());
-- =========================
-- SCRIPT DE LIMPIEZA (EJECUTAR PRIMERO SI YA EXISTE)
-- =========================

-- =========================
-- TABLA BITÁCORA
-- =========================
CREATE TABLE bitacora (
    id INT AUTO_INCREMENT PRIMARY KEY,
    fecha TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    usuario VARCHAR(100),
    email VARCHAR(100),
    rol VARCHAR(50),
    accion VARCHAR(100),
    detalle TEXT,
    ip VARCHAR(45),
    estado_usuario VARCHAR(20) DEFAULT 'ACTIVO',
    INDEX idx_fecha (fecha),
    INDEX idx_usuario (usuario),
    INDEX idx_accion (accion)
);

-- =========================
-- PROCEDIMIENTO PARA INSERTAR EN BITÁCORA
-- =========================
DELIMITER //

CREATE PROCEDURE sp_log_bitacora(
    IN p_usuario_id INT,
    IN p_accion VARCHAR(100),
    IN p_detalle TEXT,
    IN p_ip VARCHAR(45)
)
BEGIN
    DECLARE v_usuario VARCHAR(100);
    DECLARE v_email VARCHAR(100);
    DECLARE v_rol VARCHAR(50);
    DECLARE v_estado VARCHAR(20);

    -- Si no viene IP, lo dejamos como NULL
    IF p_ip IS NULL THEN
        SET p_ip = '';
    END IF;

    -- Obtener datos del usuario
    SELECT u.nombre, u.email, r.nombre, IF(u.activo, 'ACTIVO', 'INACTIVO')
    INTO v_usuario, v_email, v_rol, v_estado
    FROM usuarios u
    JOIN roles r ON u.rol_id = r.id
    WHERE u.id = p_usuario_id;

    -- Insertar en bitácora
    INSERT INTO bitacora (usuario, email, rol, accion, detalle, ip, estado_usuario)
    VALUES (v_usuario, v_email, v_rol, p_accion, p_detalle, p_ip, v_estado);
END //

DELIMITER ;

-- =========================
-- TRIGGERS PARA USUARIOS
-- =========================
DELIMITER //

CREATE TRIGGER trg_bitacora_usuarios_insert
AFTER INSERT ON usuarios
FOR EACH ROW
BEGIN
    CALL sp_log_bitacora(NEW.id, 'USUARIO CREADO', 
        CONCAT('Nuevo usuario: ', NEW.nombre, ' con email: ', NEW.email), NULL);
END //

CREATE TRIGGER trg_bitacora_usuarios_update
AFTER UPDATE ON usuarios
FOR EACH ROW
BEGIN
    DECLARE v_cambios TEXT;

    SET v_cambios = '';

    IF OLD.nombre <> NEW.nombre THEN
        SET v_cambios = CONCAT(v_cambios, 'Nombre: ', OLD.nombre, ' → ', NEW.nombre, '; ');
    END IF;

    IF OLD.email <> NEW.email THEN
        SET v_cambios = CONCAT(v_cambios, 'Email: ', OLD.email, ' → ', NEW.email, '; ');
    END IF;

    IF OLD.password <> NEW.password THEN
        SET v_cambios = CONCAT(v_cambios, 'Contraseña cambiada; ');
    END IF;

    IF OLD.rol_id <> NEW.rol_id THEN
        SET v_cambios = CONCAT(v_cambios, 'Rol cambiado; ');
    END IF;

    IF OLD.activo <> NEW.activo THEN
        SET v_cambios = CONCAT(v_cambios, 'Estado: ', IF(OLD.activo,'ACTIVO','INACTIVO'), 
            ' → ', IF(NEW.activo,'ACTIVO','INACTIVO'), '; ');
    END IF;

    IF v_cambios <> '' THEN
        CALL sp_log_bitacora(NEW.id, 'USUARIO MODIFICADO', v_cambios, NULL);
    END IF;
END //

CREATE TRIGGER trg_bitacora_usuarios_delete
BEFORE DELETE ON usuarios
FOR EACH ROW
BEGIN
    CALL sp_log_bitacora(OLD.id, 'USUARIO ELIMINADO', 
        CONCAT('Usuario eliminado: ', OLD.nombre, ' (', OLD.email, ')'), NULL);
END //

-- =========================
-- TRIGGERS PARA CURSOS
-- =========================
CREATE TRIGGER trg_bitacora_cursos_insert
AFTER INSERT ON cursos
FOR EACH ROW
BEGIN
    CALL sp_log_bitacora(NEW.profesor_id, 'CURSO CREADO', 
        CONCAT('Nuevo curso: ', NEW.nombre), NULL);
END //

CREATE TRIGGER trg_bitacora_cursos_update
AFTER UPDATE ON cursos
FOR EACH ROW
BEGIN
    DECLARE v_cambios TEXT;

    SET v_cambios = '';

    IF OLD.nombre <> NEW.nombre THEN
        SET v_cambios = CONCAT(v_cambios, 'Nombre: ', OLD.nombre, ' → ', NEW.nombre, '; ');
    END IF;

    IF OLD.descripcion <> NEW.descripcion THEN
        SET v_cambios = CONCAT(v_cambios, 'Descripción modificada; ');
    END IF;

    CALL sp_log_bitacora(NEW.profesor_id, 'CURSO MODIFICADO', 
        CONCAT('Curso: ', NEW.nombre, ' - ', v_cambios), NULL);
END //

CREATE TRIGGER trg_bitacora_cursos_delete
BEFORE DELETE ON cursos
FOR EACH ROW
BEGIN
    CALL sp_log_bitacora(OLD.profesor_id, 'CURSO ELIMINADO', 
        CONCAT('Curso eliminado: ', OLD.nombre), NULL);
END //

-- =========================
-- TRIGGERS PARA INSCRIPCIONES
-- =========================
CREATE TRIGGER trg_bitacora_inscripciones_insert
AFTER INSERT ON inscripciones
FOR EACH ROW
BEGIN
    DECLARE v_curso_nombre VARCHAR(100);
    SELECT nombre INTO v_curso_nombre FROM cursos WHERE id = NEW.curso_id;

    CALL sp_log_bitacora(NEW.usuario_id, 'INSCRIPCIÓN', 
        CONCAT('Se inscribió al curso: ', v_curso_nombre), NULL);
END //

CREATE TRIGGER trg_bitacora_inscripciones_delete
BEFORE DELETE ON inscripciones
FOR EACH ROW
BEGIN
    DECLARE v_curso_nombre VARCHAR(100);
    SELECT nombre INTO v_curso_nombre FROM cursos WHERE id = OLD.curso_id;

    CALL sp_log_bitacora(OLD.usuario_id, 'DESINSCRIPCIÓN', 
        CONCAT('Se desinscribió del curso: ', v_curso_nombre), NULL);
END //

DELIMITER ;

-- =========================
-- PROCEDIMIENTOS PARA SESIONES
-- =========================
DELIMITER //

CREATE PROCEDURE sp_log_login(
    IN p_usuario_id INT,
    IN p_ip VARCHAR(45),
    IN p_exitoso BOOLEAN
)
BEGIN
    IF p_exitoso THEN
        CALL sp_log_bitacora(p_usuario_id, 'LOGIN EXITOSO', 'Usuario inició sesión', p_ip);
    ELSE
        CALL sp_log_bitacora(p_usuario_id, 'LOGIN FALLIDO', 'Intento de login fallido', p_ip);
    END IF;
END //

CREATE PROCEDURE sp_log_logout(
    IN p_usuario_id INT,
    IN p_ip VARCHAR(45)
)
BEGIN
    CALL sp_log_bitacora(p_usuario_id, 'LOGOUT', 'Usuario cerró sesión', p_ip);
END //

CREATE PROCEDURE sp_log_actividad(
    IN p_usuario_id INT,
    IN p_actividad TEXT,
    IN p_ip VARCHAR(45)
)
BEGIN
    CALL sp_log_bitacora(p_usuario_id, 'ACTIVIDAD', p_actividad, p_ip);
END //

DELIMITER ;

-- =========================
-- MIGRAR DATOS EXISTENTES DE logs_acceso
-- =========================
INSERT INTO bitacora (fecha, usuario, email, rol, accion, detalle, estado_usuario)
SELECT 
    l.fecha,
    u.nombre,
    u.email,
    r.nombre,
    l.accion,
    l.accion,
    IF(u.activo, 'ACTIVO', 'INACTIVO')
FROM logs_acceso l
JOIN usuarios u ON l.usuario_id = u.id
JOIN roles r ON u.rol_id = r.id;

use gestion_cursos;

DROP TABLE IF EXISTS password_historial;
CREATE TABLE password_historial (
  id INT AUTO_INCREMENT PRIMARY KEY,
  usuario_id INT NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  creado_en TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  INDEX idx_ph_usuario_creado (usuario_id, creado_en),
  CONSTRAINT fk_password_historial_usuario
    FOREIGN KEY (usuario_id) REFERENCES usuarios(id)
    ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
-- ===========


SET GLOBAL event_scheduler = ON;

-- =====================================================
-- SCRIPT COMPLETO PARA SISTEMA DE SUSCRIPCIONES Y SESIONES
-- =====================================================

-- Habilitar el event scheduler
SET GLOBAL event_scheduler = ON;

-- =====================================================
-- TABLAS DEL SISTEMA DE SUSCRIPCIONES
-- =====================================================

-- Tabla de suscripciones disponibles
CREATE TABLE IF NOT EXISTS suscripciones (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    descripcion TEXT,
    tipo ENUM('basica', 'premium', 'familiar') NOT NULL,
    sesiones_concurrentes INT NOT NULL DEFAULT 1,
    usuarios_maximos INT NOT NULL DEFAULT 1,
    duracion_dias INT NOT NULL DEFAULT 30,
    precio DECIMAL(10,2) NOT NULL DEFAULT 0.00,
    activo BOOLEAN NOT NULL DEFAULT 1,
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    fecha_actualizacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla de suscripciones de usuarios
CREATE TABLE IF NOT EXISTS usuarios_suscripcion (
    id INT AUTO_INCREMENT PRIMARY KEY,
    usuario_id INT NOT NULL,
    suscripcion_id INT NOT NULL,
    fecha_inicio TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    fecha_fin TIMESTAMP NULL,
    activo BOOLEAN NOT NULL DEFAULT 1,
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (usuario_id) REFERENCES usuarios(id) ON DELETE CASCADE,
    FOREIGN KEY (suscripcion_id) REFERENCES suscripciones(id) ON DELETE CASCADE,
    UNIQUE KEY unique_usuario_activo (usuario_id, activo)
);

-- Tabla de sesiones activas
CREATE TABLE IF NOT EXISTS sesiones_activas (
    id INT AUTO_INCREMENT PRIMARY KEY,
    usuario_id INT NOT NULL,
    session_id VARCHAR(255) NOT NULL,
    ip_address VARCHAR(45),
    user_agent TEXT,
    fecha_inicio TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    fecha_ultima_actividad TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    activo BOOLEAN NOT NULL DEFAULT 1,
    FOREIGN KEY (usuario_id) REFERENCES usuarios(id) ON DELETE CASCADE,
    UNIQUE KEY unique_session (session_id)
);

-- Tabla de familias (para suscripción familiar)
CREATE TABLE IF NOT EXISTS familias (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    suscripcion_id INT NOT NULL,
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (suscripcion_id) REFERENCES suscripciones(id) ON DELETE CASCADE
);

-- Tabla de miembros de familia
CREATE TABLE IF NOT EXISTS familia_miembros (
    id INT AUTO_INCREMENT PRIMARY KEY,
    familia_id INT NOT NULL,
    usuario_id INT NOT NULL,
    fecha_agregado TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (familia_id) REFERENCES familias(id) ON DELETE CASCADE,
    FOREIGN KEY (usuario_id) REFERENCES usuarios(id) ON DELETE CASCADE,
    UNIQUE KEY unique_miembro (familia_id, usuario_id)
);

-- =====================================================
-- DATOS INICIALES DE SUSCRIPCIONES
-- =====================================================

INSERT INTO suscripciones (nombre, descripcion, tipo, sesiones_concurrentes, usuarios_maximos, duracion_dias, precio, activo) VALUES
('Básica Gratuita', 'Acceso básico con 1 sesión concurrente', 'basica', 1, 1, 30, 0.00, 1),
('Premium Mensual', 'Acceso premium con 3 sesiones concurrentes', 'premium', 3, 1, 30, 9.99, 1),
('Premium Anual', 'Acceso premium anual con 3 sesiones concurrentes', 'premium', 3, 1, 365, 99.99, 1),
('Familiar Mensual', 'Acceso familiar con 5 usuarios simultáneos', 'familiar', 5, 5, 30, 19.99, 1),
('Familiar Anual', 'Acceso familiar anual con 5 usuarios simultáneos', 'familiar', 5, 5, 365, 199.99, 1);

-- =====================================================
-- PROCEDIMIENTOS ALMACENADOS
-- =====================================================

DELIMITER //

-- Procedimiento para verificar si un usuario puede iniciar sesión
CREATE PROCEDURE sp_verificar_sesion_disponible(
    IN p_usuario_id INT
)
BEGIN
    DECLARE v_suscripcion_id INT;
    DECLARE v_sesiones_concurrentes INT;
    DECLARE v_sesiones_activas INT;
    DECLARE v_puede_iniciar BOOLEAN DEFAULT 1;
    DECLARE v_mensaje VARCHAR(255) DEFAULT 'Puede iniciar sesión';
    
    -- Obtener la suscripción activa del usuario
    SELECT us.suscripcion_id, s.sesiones_concurrentes
    INTO v_suscripcion_id, v_sesiones_concurrentes
    FROM usuarios_suscripcion us
    JOIN suscripciones s ON us.suscripcion_id = s.id
    WHERE us.usuario_id = p_usuario_id AND us.activo = 1
    LIMIT 1;
    
    -- Si no tiene suscripción, asignar básica gratuita
    IF v_suscripcion_id IS NULL THEN
        INSERT INTO usuarios_suscripcion (usuario_id, suscripcion_id, fecha_fin)
        VALUES (p_usuario_id, 1, DATE_ADD(NOW(), INTERVAL 30 DAY));
        
        SET v_suscripcion_id = 1;
        SET v_sesiones_concurrentes = 1;
    END IF;
    
    -- Contar sesiones activas del usuario
    SELECT COUNT(*)
    INTO v_sesiones_activas
    FROM sesiones_activas
    WHERE usuario_id = p_usuario_id AND activo = 1;
    
    -- Verificar si puede iniciar sesión
    IF v_sesiones_activas >= v_sesiones_concurrentes THEN
        SET v_puede_iniciar = 0;
        SET v_mensaje = CONCAT('Límite de sesiones alcanzado. Tienes ', v_sesiones_activas, ' de ', v_sesiones_concurrentes, ' sesiones activas.');
    END IF;
    
    -- Retornar resultados
    SELECT v_puede_iniciar as puede_iniciar, v_sesiones_activas as sesiones_activas, 
           v_sesiones_concurrentes as limite_sesiones, v_mensaje as mensaje;
END //
DELIMITER //
-- Procedimiento para registrar una nueva sesión
CREATE PROCEDURE sp_registrar_sesion(
    IN p_usuario_id INT,
    IN p_session_id VARCHAR(255),
    IN p_ip_address VARCHAR(45),
    IN p_user_agent TEXT
)
BEGIN
    DECLARE v_suscripcion_id INT;
    DECLARE v_sesiones_concurrentes INT;
    DECLARE v_sesiones_activas INT;
    DECLARE v_exito BOOLEAN DEFAULT 1;
    DECLARE v_mensaje VARCHAR(255) DEFAULT 'Sesión registrada correctamente';
    
    -- Obtener la suscripción activa del usuario
    SELECT us.suscripcion_id, s.sesiones_concurrentes
    INTO v_suscripcion_id, v_sesiones_concurrentes
    FROM usuarios_suscripcion us
    JOIN suscripciones s ON us.suscripcion_id = s.id
    WHERE us.usuario_id = p_usuario_id AND us.activo = 1
    LIMIT 1;
    
    -- Si no tiene suscripción, asignar básica gratuita
    IF v_suscripcion_id IS NULL THEN
        INSERT INTO usuarios_suscripcion (usuario_id, suscripcion_id, fecha_fin)
        VALUES (p_usuario_id, 1, DATE_ADD(NOW(), INTERVAL 30 DAY));
        
        SET v_suscripcion_id = 1;
        SET v_sesiones_concurrentes = 1;
    END IF;
    
    -- Contar sesiones activas del usuario
    SELECT COUNT(*)
    INTO v_sesiones_activas
    FROM sesiones_activas
    WHERE usuario_id = p_usuario_id AND activo = 1;
    
    -- Verificar límite de sesiones
    IF v_sesiones_activas >= v_sesiones_concurrentes THEN
        -- Cerrar la sesión más antigua si es básica
        IF v_sesiones_concurrentes = 1 THEN
            UPDATE sesiones_activas 
            SET activo = 0 
            WHERE usuario_id = p_usuario_id AND activo = 1
            ORDER BY fecha_inicio ASC 
            LIMIT 1;
        ELSE
            SET v_exito = 0;
            SET v_mensaje = CONCAT('Límite de sesiones alcanzado. Tienes ', v_sesiones_activas, ' de ', v_sesiones_concurrentes, ' sesiones activas.');
        END IF;
    END IF;
    
    -- Registrar la nueva sesión si es posible
    IF v_exito = 1 THEN
        INSERT INTO sesiones_activas (usuario_id, session_id, ip_address, user_agent)
        VALUES (p_usuario_id, p_session_id, p_ip_address, p_user_agent);
    END IF;
    
    -- Retornar resultados
    SELECT v_exito as exito, v_mensaje as mensaje;
END //
DELIMITER //
-- Procedimiento para cerrar una sesión específica
CREATE PROCEDURE sp_cerrar_sesion(
    IN p_session_id VARCHAR(255)
)
BEGIN
    UPDATE sesiones_activas 
    SET activo = 0 
    WHERE session_id = p_session_id AND activo = 1;
    
    SELECT ROW_COUNT() as sesiones_cerradas;
END //
DELIMITER //
-- Procedimiento para cerrar todas las sesiones de un usuario
CREATE PROCEDURE sp_cerrar_todas_sesiones_usuario(
    IN p_usuario_id INT
)
BEGIN
    UPDATE sesiones_activas 
    SET activo = 0 
    WHERE usuario_id = p_usuario_id AND activo = 1;
    
    SELECT ROW_COUNT() as sesiones_cerradas;
END //
DELIMITER //
-- Procedimiento para obtener sesiones activas de un usuario
CREATE PROCEDURE sp_obtener_sesiones_activas(
    IN p_usuario_id INT
)
BEGIN
    SELECT 
        id,
        session_id,
        ip_address,
        user_agent,
        fecha_inicio,
        fecha_ultima_actividad,
        TIMESTAMPDIFF(MINUTE, fecha_ultima_actividad, NOW()) as minutos_inactivo
    FROM sesiones_activas
    WHERE usuario_id = p_usuario_id AND activo = 1
    ORDER BY fecha_ultima_actividad DESC;
END //
DELIMITER //
-- Procedimiento para limpiar sesiones inactivas
CREATE PROCEDURE sp_limpiar_sesiones_inactivas(
    IN p_minutos_inactividad INT
)
BEGIN
    IF p_minutos_inactividad IS NULL THEN
        SET p_minutos_inactividad = 30;
    END IF;
    
    UPDATE sesiones_activas 
    SET activo = 0 
    WHERE activo = 1 
    AND TIMESTAMPDIFF(MINUTE, fecha_ultima_actividad, NOW()) > p_minutos_inactividad;
    
    SELECT ROW_COUNT() as sesiones_limpiadas;
END //
DELIMITER //
-- Procedimiento para actualizar actividad de sesión
CREATE PROCEDURE sp_actualizar_actividad_sesion(
    IN p_session_id VARCHAR(255)
)
BEGIN
    UPDATE sesiones_activas 
    SET fecha_ultima_actividad = NOW()
    WHERE session_id = p_session_id AND activo = 1;
    
    SELECT ROW_COUNT() > 0 as exito;
END //
DELIMITER //
-- Procedimiento para obtener suscripción de un usuario
CREATE PROCEDURE sp_obtener_suscripcion_usuario(
    IN p_usuario_id INT
)
BEGIN
    SELECT 
        s.id as suscripcion_id,
        s.nombre as suscripcion_nombre,
        s.descripcion as suscripcion_descripcion,
        s.tipo as tipo_suscripcion,
        s.sesiones_concurrentes,
        s.usuarios_maximos,
        s.precio,
        us.fecha_inicio,
        us.fecha_fin,
        us.activo as suscripcion_activa,
        (SELECT COUNT(*) FROM sesiones_activas WHERE usuario_id = p_usuario_id AND activo = 1) as sesiones_activas_actuales
    FROM usuarios_suscripcion us
    JOIN suscripciones s ON us.suscripcion_id = s.id
    WHERE us.usuario_id = p_usuario_id AND us.activo = 1
    LIMIT 1;
END //
DELIMITER //
-- Procedimiento para obtener estadísticas de sesiones
CREATE PROCEDURE sp_obtener_estadisticas_sesiones()
BEGIN
    SELECT 
        (SELECT COUNT(*) FROM sesiones_activas WHERE activo = 1) as total_sesiones_activas,
        (SELECT COUNT(DISTINCT usuario_id) FROM sesiones_activas WHERE activo = 1) as usuarios_con_sesion,
        (SELECT AVG(TIMESTAMPDIFF(MINUTE, fecha_inicio, fecha_ultima_actividad)) 
         FROM sesiones_activas WHERE activo = 1) as promedio_minutos_sesion;
END //
DELIMITER //
-- Procedimiento para obtener suscripciones disponibles
CREATE PROCEDURE sp_obtener_suscripciones_disponibles()
BEGIN
    SELECT 
        id,
        nombre,
        descripcion,
        tipo,
        sesiones_concurrentes,
        usuarios_maximos,
        duracion_dias,
        precio,
        activo
    FROM suscripciones
    WHERE activo = 1
    ORDER BY precio ASC, tipo ASC;
END //
DELIMITER //
-- Procedimiento para asignar suscripción a un usuario
CREATE PROCEDURE sp_asignar_suscripcion(
    IN p_usuario_id INT,
    IN p_suscripcion_id INT,
    IN p_fecha_fin TIMESTAMP
)
BEGIN
    DECLARE v_exito BOOLEAN DEFAULT 1;
    DECLARE v_mensaje VARCHAR(255) DEFAULT 'Suscripción asignada correctamente';
    
    -- Desactivar suscripción actual si existe
    UPDATE usuarios_suscripcion 
    SET activo = 0 
    WHERE usuario_id = p_usuario_id AND activo = 1;
    
    -- Insertar nueva suscripción
    INSERT INTO usuarios_suscripcion (usuario_id, suscripcion_id, fecha_fin)
    VALUES (p_usuario_id, p_suscripcion_id, p_fecha_fin);
    
    SELECT v_exito as exito, v_mensaje as mensaje;
END //
DELIMITER //
-- Procedimiento para verificar si una sesión está activa
CREATE PROCEDURE sp_sesion_activa(
    IN p_session_id VARCHAR(255)
)
BEGIN
    SELECT COUNT(*) > 0 as activa
    FROM sesiones_activas
    WHERE session_id = p_session_id AND activo = 1;
END //

DELIMITER ;

-- =====================================================
-- TRIGGERS
-- =====================================================

DELIMITER //

-- Trigger para bitácora de sesión iniciada
CREATE TRIGGER trg_bitacora_sesion_iniciada
AFTER INSERT ON sesiones_activas
FOR EACH ROW
BEGIN
    INSERT INTO bitacora (usuario_id, accion, tabla, registro_id, detalles, fecha)
    VALUES (NEW.usuario_id, 'INSERT', 'sesiones_activas', NEW.id, 
            CONCAT('Sesión iniciada - IP: ', NEW.ip_address), NOW());
END //

-- Trigger para bitácora de sesión cerrada
CREATE TRIGGER trg_bitacora_sesion_cerrada
AFTER UPDATE ON sesiones_activas
FOR EACH ROW
BEGIN
    IF OLD.activo = 1 AND NEW.activo = 0 THEN
        INSERT INTO bitacora (usuario_id, accion, tabla, registro_id, detalles, fecha)
        VALUES (NEW.usuario_id, 'UPDATE', 'sesiones_activas', NEW.id, 
                'Sesión cerrada', NOW());
    END IF;
END //

-- Trigger para bitácora de cambio de suscripción
CREATE TRIGGER trg_bitacora_suscripcion_cambiada
AFTER INSERT ON usuarios_suscripcion
FOR EACH ROW
BEGIN
    INSERT INTO bitacora (usuario_id, accion, tabla, registro_id, detalles, fecha)
    VALUES (NEW.usuario_id, 'INSERT', 'usuarios_suscripcion', NEW.id, 
            CONCAT('Suscripción asignada - ID: ', NEW.suscripcion_id), NOW());
END //

DELIMITER ;

-- =====================================================
-- EVENTOS
-- =====================================================

-- Evento para limpiar sesiones inactivas cada 5 minutos
CREATE EVENT IF NOT EXISTS ev_limpiar_sesiones_inactivas
ON SCHEDULE EVERY 5 MINUTE
DO
    CALL sp_limpiar_sesiones_inactivas(30);

-- Evento para desactivar suscripciones expiradas diariamente
CREATE EVENT IF NOT EXISTS ev_desactivar_suscripciones_expiradas
ON SCHEDULE EVERY 1 DAY
STARTS CURRENT_TIMESTAMP
DO
    UPDATE usuarios_suscripcion 
    SET activo = 0 
    WHERE activo = 1 
    AND fecha_fin IS NOT NULL 
    AND fecha_fin < NOW();

-- =====================================================
-- ÍNDICES PARA OPTIMIZACIÓN
-- =====================================================

CREATE INDEX idx_sesiones_activas_usuario ON sesiones_activas(usuario_id, activo);
CREATE INDEX idx_sesiones_activas_session ON sesiones_activas(session_id);
CREATE INDEX idx_sesiones_activas_fecha ON sesiones_activas(fecha_ultima_actividad);
CREATE INDEX idx_usuarios_suscripcion_usuario ON usuarios_suscripcion(usuario_id, activo);
CREATE INDEX idx_usuarios_suscripcion_fecha ON usuarios_suscripcion(fecha_fin);



CREATE TABLE IF NOT EXISTS transacciones (
    id INT AUTO_INCREMENT PRIMARY KEY,
    usuario_id INT NOT NULL,
    suscripcion_id INT NOT NULL,
    monto DECIMAL(10,2) NOT NULL,
    metodo_pago VARCHAR(50) NOT NULL,
    estado ENUM('pendiente', 'completada', 'fallida', 'reembolsada') NOT NULL DEFAULT 'pendiente',
    fecha_transaccion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    fecha_actualizacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    detalles TEXT,
    FOREIGN KEY (usuario_id) REFERENCES usuarios(id) ON DELETE CASCADE,
    FOREIGN KEY (suscripcion_id) REFERENCES suscripciones(id) ON DELETE CASCADE
);

-- Índices para transacciones
CREATE INDEX idx_transacciones_usuario ON transacciones(usuario_id);
CREATE INDEX idx_transacciones_fecha ON transacciones(fecha_transaccion);
CREATE INDEX idx_transacciones_estado ON transacciones(estado);


USE gestion_cursos;

-- =====================================================
-- ACTUALIZAR PROCEDIMIENTO sp_verificar_sesion_disponible
-- =====================================================

DROP PROCEDURE IF EXISTS sp_verificar_sesion_disponible;

DELIMITER //
CREATE PROCEDURE sp_verificar_sesion_disponible(
    IN p_usuario_id INT
)
BEGIN
    DECLARE v_suscripcion_id INT;
    DECLARE v_sesiones_concurrentes INT;
    DECLARE v_sesiones_activas INT;
    DECLARE v_puede_iniciar BOOLEAN DEFAULT 1;
    DECLARE v_mensaje VARCHAR(255) DEFAULT 'Puede iniciar sesión';
    
    -- Obtener la suscripción activa del usuario
    SELECT us.suscripcion_id, s.sesiones_concurrentes
    INTO v_suscripcion_id, v_sesiones_concurrentes
    FROM usuarios_suscripcion us
    JOIN suscripciones s ON us.suscripcion_id = s.id
    WHERE us.usuario_id = p_usuario_id AND us.activo = 1
    LIMIT 1;
    
    -- Si no tiene suscripción, asignar básica gratuita
    IF v_suscripcion_id IS NULL THEN
        INSERT INTO usuarios_suscripcion (usuario_id, suscripcion_id, fecha_fin)
        VALUES (p_usuario_id, 1, DATE_ADD(NOW(), INTERVAL 30 DAY));
        
        SET v_suscripcion_id = 1;
        SET v_sesiones_concurrentes = 1;
    END IF;
    
    -- Contar sesiones activas del usuario
    SELECT COUNT(*)
    INTO v_sesiones_activas
    FROM sesiones_activas
    WHERE usuario_id = p_usuario_id AND activo = 1;
    
    -- Siempre puede iniciar sesión (se cerrará la más antigua si es necesario)
    -- Solo mostrar advertencia si está en el límite
    IF v_sesiones_activas >= v_sesiones_concurrentes THEN
        SET v_mensaje = CONCAT('Se cerrará la sesión más antigua para permitir esta nueva sesión. Límite: ', v_sesiones_concurrentes, ' sesiones.');
    END IF;
    
    -- Retornar resultados
    SELECT v_puede_iniciar as puede_iniciar, v_sesiones_activas as sesiones_activas, 
           v_sesiones_concurrentes as limite_sesiones, v_mensaje as mensaje;
END //
DELIMITER ;

-- =====================================================
-- ACTUALIZAR PROCEDIMIENTO sp_registrar_sesion
-- =====================================================

DROP PROCEDURE IF EXISTS sp_registrar_sesion;

DELIMITER //
CREATE PROCEDURE sp_registrar_sesion(
    IN p_usuario_id INT,
    IN p_session_id VARCHAR(255),
    IN p_ip_address VARCHAR(45),
    IN p_user_agent TEXT
)
BEGIN
    DECLARE v_suscripcion_id INT;
    DECLARE v_sesiones_concurrentes INT;
    DECLARE v_sesiones_activas INT;
    DECLARE v_exito BOOLEAN DEFAULT 1;
    DECLARE v_mensaje VARCHAR(255) DEFAULT 'Sesión registrada correctamente';
    
    -- Obtener la suscripción activa del usuario
    SELECT us.suscripcion_id, s.sesiones_concurrentes
    INTO v_suscripcion_id, v_sesiones_concurrentes
    FROM usuarios_suscripcion us
    JOIN suscripciones s ON us.suscripcion_id = s.id
    WHERE us.usuario_id = p_usuario_id AND us.activo = 1
    LIMIT 1;
    
    -- Si no tiene suscripción, asignar básica gratuita
    IF v_suscripcion_id IS NULL THEN
        INSERT INTO usuarios_suscripcion (usuario_id, suscripcion_id, fecha_fin)
        VALUES (p_usuario_id, 1, DATE_ADD(NOW(), INTERVAL 30 DAY));
        
        SET v_suscripcion_id = 1;
        SET v_sesiones_concurrentes = 1;
    END IF;
    
    -- Contar sesiones activas del usuario
    SELECT COUNT(*)
    INTO v_sesiones_activas
    FROM sesiones_activas
    WHERE usuario_id = p_usuario_id AND activo = 1;
    
    -- Verificar límite de sesiones
    IF v_sesiones_activas >= v_sesiones_concurrentes THEN
        -- Cerrar la sesión más antigua para hacer espacio
        UPDATE sesiones_activas 
        SET activo = 0 
        WHERE usuario_id = p_usuario_id AND activo = 1
        ORDER BY fecha_inicio ASC 
        LIMIT 1;
        
        SET v_mensaje = CONCAT('Se cerró la sesión más antigua para permitir esta nueva sesión. Límite: ', v_sesiones_concurrentes, ' sesiones.');
    END IF;
    
    -- Registrar la nueva sesión
    INSERT INTO sesiones_activas (usuario_id, session_id, ip_address, user_agent)
    VALUES (p_usuario_id, p_session_id, p_ip_address, p_user_agent);
    
    -- Retornar resultados
    SELECT v_exito as exito, v_mensaje as mensaje;
END //
DELIMITER ;

-- =====================================================
-- VERIFICAR QUE LOS CAMBIOS SE APLICARON CORRECTAMENTE
-- =====================================================

SELECT 'Procedimientos actualizados correctamente' as resultado;

-- Mostrar información de las suscripciones disponibles
SELECT 
    id,
    nombre,
    sesiones_concurrentes,
    precio
FROM suscripciones 
WHERE activo = 1
ORDER BY precio ASC;
use gestion_cursos;
select * from sesiones_activas;